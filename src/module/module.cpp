#include "module.h"
#include "../core.h"
#include <stddef.h>
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SmartModule* _Module = NULL; // рабочий экземпляр модуля
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SmartModule::SmartModule(const char* _moduleName, uint8_t _moduleID, Transport& t, _Storage& s)
{
	moduleName = _moduleName;
	moduleID = _moduleID;
	storage = &s;
	transport = &t;
	controllerID = 0xFFFFFFFF;
	canWork = false;
	
	_Module = this;
	
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SmartModule::~SmartModule()
{
	for(size_t i=0;i<events.size();i++)
	{
		delete events[i];
	}
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::linkToController(uint32_t _controllerID)
{
	controllerID = _controllerID;
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool SmartModule::registered()
{
	return (controllerID != 0xFFFFFFFF);
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::begin()
{
	canWork = (transport && storage);
	if(!canWork)
	{
		DBGLN(F("[ERR]: No storage or transport, can't work !!!"));
		return;
	}
		
	// читаем сохранённый ID контроллера, к которому мы привязаны
	StorageReader::read(storage,0,controllerID);
	
	// запускаем транспорт
	transport->begin();
	
	DBGLN(F("Module started."));
	
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::startRegistration(uint32_t timeout)
{
	if(inRegMode) // уже в режиме регистрации
	{
		DBGLN(F("Already in registration mode!"));
		return;
	}
	// переходим в режим регистрации
	DBGLN(F("Switch to registration mode!"));
	
	oldControllerID = controllerID;
	controllerID = 0xFFFFFFFF;
	inRegMode = true;
	regTimeout = timeout;
	regStartedAt = uptime();
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::update()
{
	if(!canWork)
		return;
	
	// не допускаем вложенных вызовов update() из update()
	static bool inUpdate = false;
	
	if(inUpdate)
		return;
	
	inUpdate = true;
	
	// проверяем - если мы в режиме регистрации и она слишком долго длится - выходим из неё
	if(inRegMode && uptime() - regStartedAt >= regTimeout)
	{
		inRegMode = false;
		controllerID = oldControllerID;
		// посылаем событие, что регистрация прошла неудачно
		registration(false);
		
	}
	
	// для начала - сбрасываем флаг получения новых данных с контроллера у всех наблюдаемых слотов
	for(size_t i=0;i<observeList.size();i++)
	{
		observeList[i].data->trigger(false);
	}
	
	// теперь, если мы получим новые данные для слота - то проверка на isTriggered() для этого слота
	// будет срабатывать до следующего вызова update()
	
	// далее - нам надо проверить, не протухли ли у нас какие-либо данные в списке наблюдаемых слотов?
	uint32_t now = uptime();
	for(size_t i=0;i<observeList.size();i++)
	{
		if( (now - observeList[i].lastDataAt) >= observeList[i].timeout)
		{
			DBG(F("[TIMEOUT] reset slot #"));
			DBGLN(observeList[i].data->getID());

			// данные протухли, надо сбросить показания датчика, триггер взведётся автоматически
			observeList[i].data->reset();
			observeList[i].lastDataAt = now; // обновляем таймер
		}
	}
	
	// обновляем транспорт
	transport->update();
	
	// проверяем, принял ли транспорт какой-нибудь пакет?
	if(transport->available())
	{
		processIncomingMessage(); // обрабатываем входящее сообщение
	}
	
	// все входящие сообщения обработаны
	
	inUpdate = false;
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::processIncomingMessage()
{
	// в транспорте есть сообщение для нас, получаем его
	uint16_t payloadLength;
	uint8_t* payload = transport->read(payloadLength);
	
	// тут парсим сообщение и понимаем, что к чему
	Message m = Message::parse(payload,payloadLength);
	
	// говорим транспорту, что мы больше не нуждаемся в пакете
	transport->wipe();
	
	if(m.isEvent())
	{
		DBGLN(F("CATCH EVENT!"));
		// это событие, на него возможно реагировать по другому
		processEvent(m);
	}
	else
	{
		DBGLN(F("CATCH MESSAGE!"));
		// это обычное сообщение
		processMessage(m);
	}
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::processMessage(const Message& incoming)
{
	//TODO: обрабатываем входящее сообщение
	switch(incoming.type)
	{
		case Messages::Unknown:
		{
			// чёрт те что пришло
		}
		break;
		
		case Messages::Event:
		{
			// сообщение типа "событие" - здесь не обрабатывается
		}
		break;
		
		case Messages::RegistrationRequest:		
		{
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "запрос регистрации" (RegistrationRequest)
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------

		отсылается контроллером в эфир для поиска модуля, находящегося в режиме регистрации, структура:
		
			ID контроллера
			ID модуля = 0xFF
			Тип сообщения - "запрос регистрации" (RegistrationRequest)
			
		если в эфире есть модуль, находящийся в режиме регистрации, он должен сохранить у себя ID контроллера, и ответить сообщением "регистрация завершена" (RegistrationResult).
*/			
			if(inRegMode)
			{
				// мы в режиме регистрации, поэтому сохраняем у себя ID контроллера
				DBG(F("Register in controller #"));
				DBGLN(incoming.controllerID);
				
				controllerID = incoming.controllerID;
				inRegMode = false;
				
				// сохраняем ID контроллера в хранилище
				StorageReader::write(storage,0,controllerID);
				
				// отсылаем сообщение RegistrationResult
				DBGLN(F("Send RegistrationResult message"));
				
				Message m = Message::RegistrationResult(controllerID, moduleID);
				
				// публикуем в транспорт ответ сразу же, потому что там его ждут незамедлительно
				transport->write(m.getPayload(),m.getPayloadLength());						
				
				// посылаем событие, что мы успешно зарегистрировались
				registration(true);
				
			}
		
		}
		break;
		
		case Messages::RegistrationResult:
		{
			// сообщение типа "регистрация завершена" мы, как модуль, игнорируем

		}
		break;
		
		case Messages::Scan: // сообщение "сканирую эфир"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "сканирую эфир"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
		посылается при начале работы контроллером, предназначено для поиска зарегистрированных модулей. 
		Модуль при этом должен сброситься на начало работы своей логики (под вопросом).
		
		структура:
		
			ID контроллера
			ID модуля, к которому направлен запрос
			Тип сообщения - "сканирую эфир"
	
	
		как только модуль принял сообщение, и оно адресовано ему - он отсылает через транспорт, которым получено сообщение, сообщение вида "я на связи"

*/		
		{
			
			DBGLN(F("Messages::Scan"));
		
			if( registered() && toMe(incoming) )
			{
				// сообщение адресовано нам, на него надо ответить сообщением "я на связи"
				DBGLN(F("Send ScanResponse message"));
				
				Message m = Message::ScanResponse(controllerID, moduleID, moduleName,broadcastList.size(),observeList.size());
				
				// публикуем в транспорт ответ сразу же, потому что там его ждут незамедлительно
				transport->write(m.getPayload(),m.getPayloadLength());			
			}
		}
		break;
		
		case Messages::ScanResponse: // сообщение "я на связи"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "я на связи"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------

	отсылается дочерним модулем в ответ на сообщение "сканирую эфир", структура:
	
		ID контроллера
		ID модуля
		Тип сообщения - "я на связи"
		нагрузка:
			- длина имени модуля (1 байт)
			- символьное имя модуля
			- кол-во исходящих слотов виртуальных данных, которые публикует модуль (1 байт)
			- кол-во входящих слотов виртуальных данных, которые слушает модуль (1 байт)
*/		
		{
			DBGLN(F("Messages::ScanResponse"));
			//TODO: сообщение "я на связи" мы игнорируем, хотя тут можно и выставлять флаг, что какой-то модуль на связи
		}
		break;
		
		case Messages::Ping: // сообщение "Пинг"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "пинг"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------

		отсылается контроллером конкретному модулю для проверки связи (на тот редкий случай, когда модуль не зарегистрировал ни одного исходящего слота), структура:
		
		ID контроллера
		ID модуля
		Тип сообщения - "пинг"
*/		
		{
			DBGLN(F("Messages::Ping"));
			
			if( registered() && toMe(incoming) )
			{
				DBGLN(F("Send back Pong message."));
	
				Message m = Message::Pong(controllerID, moduleID);
				
				// публикуем в транспорт ответ сразу же, потому что там его ждут незамедлительно
				transport->write(m.getPayload(),m.getPayloadLength());

			}
		}
		break;
		
		case Messages::Pong: // сообщение "Понг"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "понг"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
		отсылается модулем на контроллер как ответ на сообщение "пинг", структура:

		ID контроллера
		ID модуля
		Тип сообщения - "понг"
*/		
		{
			DBGLN(F("Messages::Pong"));
			//TODO: сообщение "понг" мы игнорируем, хотя здесь можно и узнавать, какие модули онлайн
			if(registered() && controllerID == incoming.controllerID)
			{
				// зарегистрированы, и сообщение послал наш контроллер, можно выставлять флаг, что данный модуль онлайн				
			}
		}
		break;
		
		case Messages::BroadcastSlotRegister: // сообщение "регистрация исходящего слота"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "регистрация исходящего слота"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
		отсылается контроллером в эфир как запрос на регистрацию исходящего слота модуля в контроллере, структура:
		
			ID контроллера
			ID модуля
			Тип сообщения - "регистрация исходящего слота"
			нагрузка:
				- номер исходящего слота (1 байт)
	
	
		в ответ на это сообщение модуль отсылает в эфир сообщение "данные исходящего слота".
*/		
		{
			DBGLN(F("Messages::BroadcastSlotRegister"));
			
			if( registered() && toMe(incoming) )
			{
				// запрос на регистрацию исходящего слота, в нагрузке - номер исходящего слота в нашем списке исходящих слотов
				uint8_t slotNumber = incoming.get<uint8_t>(0);
					
				DBG(F("Requested broadcast slot data #"));
				DBGLN(slotNumber);
				
				// ищем такой слот в исходящих
				if(slotNumber < broadcastList.size())
				{
					// нашли, надо отправить сообщение "данные исходящего слота"
					AnyData* dt = broadcastList[slotNumber];
					
					Message m = Message::BroadcastSlotData
					(
						  controllerID
						, moduleID
						, dt
					);
					
					DBGLN(F("Send back BroadcastSlotData message."));
					
					transport->write(m.getPayload(),m.getPayloadLength());
				}
				
			}
		}
		break;
		
		
		case Messages::ObserveSlotData: // сообщение "данные входящего слота"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "данные входящего слота"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
		отсылается модулем как ответ на запрос "регистрация входящего слота", структура:
		
		ID контроллера
		ID модуля
		Тип сообщения - "данные входящего слота"
		нагрузка:
			- ID слота (уникальный в рамках системы ID слота, 2 байта)
			- период публикации контроллером данных слота в эфир, миллисекунд (4 байта)
*/		
		{
			// игнорируем, как модуль			
		}
		break;
		
		case Messages::ObserveSlotRegister: // сообщение "регистрация входящего слота"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "регистрация входящего слота"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
		отсылается контроллером в эфир как запрос на регистрацию входящего слота модуля в контроллере, структура:
		
			ID контроллера
			ID модуля
			Тип сообщения - "регистрация входящего слота"
			нагрузка:
				- номер входящего слота (1 байт)
	
	
		в ответ на это сообщение модуль отсылает в эфир сообщение "данные входящего слота".

*/		
		{
			DBGLN(F("Messages::ObserveSlotRegister"));
			
			if( registered() && toMe(incoming) )
			{
				// запрос на регистрацию входящего слота, в нагрузке - номер входящего слота в нашем списке входящих слотов
				uint8_t slotNumber = incoming.get<uint8_t>(0);
					
				DBG(F("Requested observe slot data #"));
				DBGLN(slotNumber);
				
				if(slotNumber < observeList.size())
				{
					// нашли, надо отправить сообщение "данные входящего слота"
					AnyDataTimer* dt = &(observeList[slotNumber]);
										
					Message m = Message::ObserveSlotData
					(
						  controllerID
						, moduleID
						, dt->data->getID()
						, dt->frequency
					);
					
					DBGLN(F("Send back ObserveSlotData message."));
					
					transport->write(m.getPayload(),m.getPayloadLength());
					
				}
			}
		}
		break;
		
		case Messages::AnyDataBroadcast: // сообщение "данные слота"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "данные слота"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
		отсылается контроллером в эфир для конкретного модуля, который зарегистрировал в контроллере свой входящий слот. Структура:
		
			ID контроллера
			ID модуля
			Тип сообщения - "данные слота"
			нагрузка:
				- ID слота (уникальный в рамках системы ID слота, 2 байта)
				- тип данных слота (температура и т.п., 2 байта)
				- флаги (наличие данных и пр., 1 байт)
				- длина данных слота (2 байта)
				- данные слота
*/		
		{
			DBGLN(F("Messages::AnyDataBroadcast"));
			
			// пришли данные входящего слота, который мы зарегистрировали на контроллере
			if( registered() && toMe(incoming) )
			{
				
				updateObserveSlot(incoming);
				
				// ничего не отвечаем, т.к. без надобности
			}
			
		}
		break;
		
		case Messages::AnyDataRequest: // сообщение "запрос данных слота"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "запрос данных слота"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
		отсылается контроллером в эфир для конкретного модуля, для запроса с него данных зарегистрированного исходящего слота. Структура:	

			ID контроллера
			ID модуля
			Тип сообщения - "запрос данных слота"
			нагрузка:
				- ID слота (уникальный в рамках системы ID слота, 2 байта)
*/		
		{				
				
			DBGLN(F("Messages::AnyDataRequest"));
			
			if( registered() && toMe(incoming) )
			{
				// наш модуль, ищем слот
				uint16_t slotID = incoming.get<uint16_t>(0);
				
				for(size_t i=0;i<broadcastList.size();i++)
				{
					if(broadcastList[i]->getID() == slotID)
					{
						// нашли						
						Message m = Message::AnyDataResponse
						(
							  controllerID
							, moduleID
							, broadcastList[i]
						);
						
						DBGLN(F("Send back AnyDataResponse message."));
						
						transport->write(m.getPayload(),m.getPayloadLength());						
							
						
						break;
					}
				} // for
			}
		}
		break;
		
		case Messages::BroadcastSlotData: // сообщение "данные исходящего слота"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "данные исходящего слота"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
		отсылается модулем в ответ на запрос "регистрация исходящего слота", структура:
		
			ID контроллера
			ID модуля
			Тип сообщения - "данные исходящего слота"
			нагрузка:
				- ID слота (уникальный в рамках системы ID слота, 2 байта)
				- тип данных слота (температура и т.п., 2 байта)
				- флаги (наличие данных и пр., 1 байт)
				- длина данных слота (2 байта)
				- данные слота
*/
		case Messages::AnyDataResponse: // сообщение "ответ данных слота"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "ответ данных слота"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
		отсылается модулем как ответ на сообщение "запрос данных слота", структура:
		
			ID контроллера
			ID модуля
			Тип сообщения - "ответ данных слота"
			нагрузка:
				- ID слота (уникальный в рамках системы ID слота, 2 байта)
				- тип данных слота (температура и т.п., 2 байта)
				- флаги (наличие данных и пр., 1 байт)
				- длина данных слота (2 байта)
				- данные слота

*/		
		{
			// эти два сообшения по нагрузке - идентичны, поэтому можно их обрабатывать в одной ветке, и с одинаковой логикой
			DBGLN(F("Messages::BroadcastSlotData or Messages::AnyDataResponse"));
			
			// В принципе, если мы зарегистрированы - то можно смотреть этот слот во входящих у нас,
			// главное - чтобы модуль-отправитель - был не наш, и всё.
			if(registered() && controllerID == incoming.controllerID && incoming.moduleID != moduleID)
			{
				// мы зарегистрированы в системе, и отправили это сообщение не мы - значит, можно искать его в наблюдаемых входящих.
				updateObserveSlot(incoming);
				
			}
		}
		break;
		
		case Messages::EventRequest: // сообщение "запрос события"
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "запрос события"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------

		отсылается контроллером в эфир для конкретного модуля, структура:
		
			ID контроллера
			ID модуля
			Тип сообщения - "запрос события"

*/		
		{
			DBGLN(F("Messages::EventRequest"));
			
				if( registered() && toMe(incoming) )
				{
					//тут проверяем, есть ли у нас события, и отвечаем сообщением EventResponse
					Event* e = getEvent();
					
					bool hasEvent = e;

					Message m = Message::EventResponse(controllerID, moduleID, hasEvent, e);
						
					DBGLN(F("Send back EventResponse message."));
						
					transport->write(m.getPayload(),m.getPayloadLength());
					
					
					if(e)
						delete e;
					
				}
		}
		break;
		
		case Messages::EventResponse: // сообщение "публикация события"
		{
			
		// здесь не обрабатываем, т.к. незачем
/*
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	сообщение "публикация события"
	---------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
		отсылается модулем в ответ на сообщение "запрос события", структура:
		
			ID контроллера
			ID модуля
			Тип сообщения - "публикация события"
			нагрузка:
				- Флаг, есть событие или нет (1 байт)
				- Тип события (2 байта) - только если есть событие
				- Длина данных события (2 байта) - только если есть событие
				- Данные события  - только если есть событие
*/			
			
		}
		break;
		
		
		
	} // switch
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::updateObserveSlot(const Message& m)
{
	// получаем ID слота
	uint16_t slotID = m.get<uint16_t>(0);
	// получаем тип данных слота
	DataType slotType = static_cast<DataType>( m.get<uint16_t>(2) );
	// получаем флаги слота
	uint8_t hasData = m.get<uint8_t>(4);
	// получаем длину данных слота
	uint16_t dataLength = 0;
	const uint8_t* data = NULL;
	if(hasData)
	{
		dataLength = m.get<uint16_t>(5);
		data = m.getPayload() + MESSAGE_HEADER_SIZE + 7; // становимся на начало данных слота
	}
		
	// ищем такой слот во входящих
	for(size_t i=0;i<observeList.size();i++)
	{
		AnyDataTimer* dt = &(observeList[i]);
		if(dt->data->getID() == slotID)
		{
			// нашли, можно обновлять данные
			
			DBG(F("Update observe slot #"));
			DBGLN(dt->data->getID());
			
			dt->lastDataAt = uptime();
			if(!hasData)
			{
				// сбрасываем данные, триггер взведётся автоматически
				dt->data->reset();
			}
			else
			{
				// есть данные, обновляем, , триггер взведётся автоматически
				dt->data->setRaw(slotType,data,dataLength);
			}
			
			
			break;
		}
	} // for	
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool SmartModule::toMe(const Message& m)
{
	return ( (m.controllerID == controllerID) && (m.moduleID == moduleID) );
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::processEvent(const Message& m)
{
	//TODO: тут обработка входящего события
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::broadcast(AnyData& data)
{
	// регистрируем слот как исходящий
	
	for(size_t i=0;i<broadcastList.size();i++)
	{
		if(broadcastList[i] == &data)
			return;
	}	
	
	broadcastList.push_back(&data);
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::observe(AnyData& data, uint32_t observeFrequency, uint32_t resetTimeout)
{
	// регистрируем слот как входящий
	
	for(size_t i=0;i<observeList.size();i++)
	{
		if(observeList[i].data == &data)
			return;
	}
	
	AnyDataTimer tm;
	tm.data = &data;
	tm.lastDataAt = uptime();
	tm.timeout = resetTimeout;
	tm.frequency = observeFrequency;
	
	observeList.push_back(tm);
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::informDataChanged(AnyData* data)
{
	// мы должны сообщить об изменении данных только тех слотов, которые помечены как исходящие.
	// для входящих слотов используется механизм триггера, т.е. код логики проверяет их на 
	// isTriggered() - и делает по факту, что нужно.
	
	if(!data)
		return;
	
	DBG(F("Slot #"));
	DBG(data->getID());
	DBGLN(F(" changed!"));
	
	// проверяем - если данные зарегистрированы как исходящие - помещаем событие SlotDataChanged в очередь событий на отправку,
	// при следующем опросе контроллером - он перечитает это дело с нас.
	
	for(size_t i=0;i<broadcastList.size();i++)
	{
		if(broadcastList[i] == data)
		{
			addEvent(Events::SlotDataChanged, data);
			break;
		}
	}		
	
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool SmartModule::eventExists(Event* e)
{
	for(size_t i=0;i<events.size();i++)
	{
		if(*(events[i]) == *e)
			return true;
	}
	
	return false;
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Event* SmartModule::getEvent()
{
	if(!events.size())
		return NULL;
	
	Event* e = events[0];
	
	for(size_t i=1;i<events.size();i++)
	{
		events[i-1] = events[i];
	}
	
	events.pop();
	
	return e;
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void SmartModule::addEvent(Events type, AnyData* data)
{
	DBG(F("Create event for slot #"));
	DBGLN(data->getID());
	
	Event* e = NULL;
	
	switch(type)
	{
		case Events::SlotDataChanged:
		{
			DBGLN(F("Create SlotDataChanged event!"));
			
			e = Event::SlotDataChanged(moduleID, data);
			
		}
		break;
		
	} // switch
	
	if(e && !eventExists(e))
	{
		// тут помещаем событие в список на отсыл
		events.push_back(e);
	}
	else
	{
		delete e;
	}
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
